Создание проекта на React + Typescript + SWC: pnpm create vite
Установка зависимостей: pnpm i
Установка типизации node: pnpm add @types/node -D
Установка React Router: pnpm i react-router
Установка Redux Toolkit и React Redux: pnpm add @reduxjs/toolkit react-redux
Установка React Hook Form: pnpm add react-hook-form

Запуск приложения: pnpm run dev

LESSON 001:

Перед установкой зависимостей в файле "package.json" можно убрать символ "^" в номерах версий, чтобы версии зависимостей
точно всегда были рабочими.

В проекте используется SWC (Speedy Web Compiler) - быстрый компилятор JavaScript/TypeScript, написанный на Rust. Он
позиционируется как замена Babel и других инструментов сборки.

Настройка импортов/алиасов:
1. В файле "tsconfig.app.json" в раздел "compilerOptions" добавить:
"baseUrl": ".",
"paths": {
    "@/*": ["src/*"]
},
Раздел "baseUrl" устанавливает, что корневая директория проекта будет являться той директорией, относительно которой TS
будет разрешать пути к модулям.
Раздел "paths" позволяет создавать алиасы для директорий. В нашем случае TS будет смотреть что находится в директории
"src" и добавлять для нее символ "@".
2. В файле "vite.config.ts" заменить код на следующий:
import path from 'path'
import {defineConfig} from 'vite'
import react from '@vitejs/plugin-react-swc'

// https://vite.dev/config/
export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            '@/': `${path.resolve(__dirname, 'src')}/`,
        },
    },
})
Разделом "resolve" указываем Vite как понимать правильно пути при сборке приложения.
3. Разрешить импорт "path" и переменной "__dirname" путем установки типизации node.
4. Чтобы сократить импорты еще сильнее, можно рядом с экспортируемыми файлами создавать файл "index.ts" для реэкспорта,
например: "export {Routing} from './Routing.tsx'".

Для роутинга в этом проекте используется библиотека React Router.

В проекте используется следующая структура директорий:
1. Папка "app" содержит общую настройку приложения и макет, который зависит от остальных папок приложения.
2. Папка "common" содержит универсальные и повторно используемые утилиты и компоненты.
3. Папка "features" содержит папки, содержащие все функциональности имеющие отношение к отдельным фичам. Папка
"features" содержит 5 сегментов:
- ui - UI-компоненты.
- api - взаимодействие с back-end.
- model - бизнес-логика.
- lib - дополнительный библиотечный код.
- config - настройки и конфигурации.

В проекте используются модульные стили.

LESSON 002:

Слайс (slice) - это часть библиотеки Redux Toolkit, которая объединяет initialState, редьюсеры и actions для
функциональности, касающейся только клиентской части. Slice - это примерно как глобальный для всего приложения хук
"useState()". Слайсы позволяет писать редьюсеры, указывая мутабельный код, так как под капотом он будет переведен в
иммутабельный при помощи библиотеки Immer.js. Слайсы позволяются автоматически создавать action creators.

RTK Query - это часть библиотеки Redux Toolkit, которая объединяет thunks и api для функциональности, касающейся обмена
данными между клиентом и сервером. RTK Query имеет:
- автоматическую отправку запросов;
- кэширование полученных данных;
- оптимистичные обновления (обновляет UI до ответа от сервера);
- избежание дублирующих запросов;
- фоновое обновление данных;
- автоматическую инвалидацию данных в кеше;
- обработку состояний загрузки и ошибок;
- интеграцию с Redux DevTools.
RTK Query использует слайсы под капотом: при создании API автоматически создаются несколько слайсов. Автоматическое
кэширование можно отключить в RTK Query.

Не для всех thunks стоит или можно использовать RTK Query. Например, для thunks со сложной клиентской логикой или с
работой с WebSocket, можно или нужно использовать "createAsyncThunk()" - тоже часть библиотеки Redux Toolkit. RTK Query
работает по модели "запрос-ответ", поэтому не подходит для работы с WebSocket, так как WebSocket работает по модели
"подписка-уведомление". Также RTK Query ожидает промис, а WebSocket НЕ возвращает промисы, и RTK Query управляет
жизненным циклом запроса, а WebSocket требует постоянного соединения.

Для работы React вместе с Redux Toolkit нужна библиотека React Redux.

Под капотом RTK Query используется хук "useEffect()", поэтому компоненты, использующие RTK Query, могут отрисовываться
несколько раз.

Чтобы создать и использовать переменные окружения в Vite нужно:
1. Создать файл ".env" для нечувствительных данных или файл ".env.local" для чувствительных данных. В файле ".env" можно
указывать пустые переменные, если они продублированы в файле ".env.local", так как у файла ".env.local" приоритет выше.
Файл ".env.local" необходимо указывать в файле ".gitignore".
2. Создать переменные окружения, имена которых должны начинаться с "VITE_".
3. Обращаться в проекте к созданным переменным окружения через объект "import.meta.env".

Порядок работы с RTK Query на React:
1. При помощи функции "createApi()" создать API.
2. При помощи функции "configureStore()" создать store.
3. Подключить созданный API в store.
4. Обернуть компонент "App" компонентом "Provider", передав в него store.
5. Экспортировать хук их созданного API.
6. Вызвать хук в компоненте и получить в ответ данные.

LESSON 003:

Для работы с формами в этом проекте используется библиотека React Hook Form.

Как можно залогиниться:
1. Перейти на "https://musicfun.it-incubator.app/api", нажать "Authorize" и указать API-ключ.
2. Перейти на "https://oauth.apihub.it-incubator.io/realms/apihub/protocol/openid-connect/auth?client_id=musicfun&response_type=code&redirect_uri=http://localhost:3000/oauth2/callback&scope=openid".
3. Залогиниться как на "apihub.it-incubator.io".
4. Из полученной ссылки взять код после "code=".
5. Вставить полученный код в поле "code" в POST-запросе на "/auth/login".
6. Из ответа взять "accessToken" и на его основе создать переменную окружения для токена доступа.
7. Прикреплять токен доступа к каждому запросу при помощи метода "prepareHeaders()":
prepareHeaders: (headers, api) => {
    headers.set('Authorization', `Bearer ${import.meta.env.VITE_ACCESS_TOKEN}`);
    return headers;
}

